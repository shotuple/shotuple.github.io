---
layout: post

title: SQLP 1. 데이터베이스 아키텍처

description: > 
  SQLP 자격증 공부

tags:
 - [자격증, SQLP]

toc: true
toc_sticky: true

date: 2022-10-07

sitemap: false

---

데이터베이스 아키텍처
===
[출처](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?pageid=2&mod=document&kboard_search_option%5Btree_category_1%5D%5Bkey%5D=tree_category_1&kboard_search_option%5Btree_category_1%5D%5Bvalue%5D=SQL+%EA%B3%A0%EA%B8%89+%ED%99%9C%EC%9A%A9+%EB%B0%8F+%ED%8A%9C%EB%8B%9D&uid=357)  

**Oracle / SQL Server**

# 1. 아키텍처 개관
## 가. 모델링의 정의
- 데이터베이스: 디스크에 저장된 데이터 집합(Datafile, Redo Log File, Control File 등)
- 인스턴스: SGA 공유 메모리 영역과 이를 액세스하는 프로세스 집합 
- 하나의 인스턴스가 하나의 데이터베이스에 액세스
    - RAC(Real Application Cluster) 환경  
    여러 인스턴스 - 하나의 데이터베이스 액세스 가능  
    하나의 인스턴스 - 여러 데이터베이스 액세스 불가능

## 나. SQL Server 아키텍처
- SQL Server는 하나의 인스턴스 당 최고 32,767개의 데이터베이스를 정의해 사용.
- 기본적으로 master, model, msdb, tempdb 등의 시스템 데이터베이스가 만들어지며, 여기에 사용자 데이터베이스를 추가로 생성.
- 데이터베이스 생성 시 주 데이터 파일(Primary 또는 Main, .mdf)과 트랜잭션 로그 파일(.ldf)이 생성, 저장할 데이터가 많으면 보조 데이터 파일(Non-Primary, ndf)을 추가.

# 2. 프로세스 / 스레드
Oracle도 Windows 버전에선 스레드를 사용하지만, 본 자료에서는 특별히 스레드를 언급해야 할 경우가 아니라면 프로세스로 통칭.

## 가. 서버 프로세스 / Worker 스레드
- 사용자 명령 처리
- SQL 파싱, 최적화 수행, 커서를 열어 SQL을 실행하고 블록 읽기, 읽은 데이터 정렬 후 요청 결과 집합을 클라이언트에게 전송.
    - 데이터 파일로부터 DB 버퍼 캐시로 블록 적재, Dirty 블록을 캐시에서 밀어내고 Free 블록 확보, Redo 로그 비우기 등은 OS, I/O 서브 시스템, 백그라운드 프로세스가 처리하도록 시스템 Call을 통해 요청.

### 1) 전용 서버(Dedicated Server) 방식
![image](https://user-images.githubusercontent.com/105637541/194479567-90e04478-9d2d-4da3-989b-32bf3f920d48.png)
- 처음 연결요청을 받는 리스너가 서버 프로세스를 생성,  
서버 프로세스가 단 하나의 사용자 프로세스를 위해 서비스.
- 연결 요청을 반복하면 서버 프로세스의 생성과 해제가 반복.  
-> DBMS에 부담, 성능 저하  
따라서 전용 서버 방식의 OLTP 성 앱에선 Connection Pooling 기법을 필수 사용. 

### 2) 공유 서버(Shared Server) 방식
![image](https://user-images.githubusercontent.com/105637541/194480186-24d637a3-dd17-409a-8c0c-ea0224be2b19.png)
- 하나의 서버 프로세스를 여러 사용자 세션이 공유.
- Connection Pooling 기법을 DBMS 내부에 구현.  
즉, 여러 개의 서버 프로세스를 띄워놓고 반복 재사용
    1. 사용자는 서버와 직접 통신하지 않고 Dispatcher 프로세스를 거침. 
    2. Dispatcher는 SGA에 있는 요청 큐(Request Queue)에 등록.
    3. 가용 서버 프로세스가 요청 큐에 있는 명령 처리 후 결과를 응답 큐에 등록.
    4. Dispatcher가 응답 큐를 사용자에게 전송.

## 나. 백그라운드 프로세스
- System Monitor(SMON) / Database cleanup, shrinking thread
    - 장애가 발생한 시스템을 재기동 시 인스턴스 복구, 임시 세그먼트와 익스텐드를 모니터링.
- Process Monitor(PMON) / Open Data Services(OPS)
    - 이상이 생긴 프로세스가 사용하던 리소스 복구.
- Database Writers(DBWn) / Lazywriter thread
    - 버퍼 캐시에 있는 Dirty 버퍼를 데이터 파일에 기록.
- Log Writer(LGWR) / Log writer thread
    - 로그 버퍼 엔트리를 Redo 로그 파일에 기록.
- Archiver(ARCn) / N/A
    - 꽉 찬 Redo 로그가 덮어쓰기 전에 Archive 로그 디렉터리로 백업.
- Checkpoint(CKPT) / Database Checkpoint thread
    - 마지막 Checkpoint 시점 이후의 변경 사항을 데이터 파일에 기록하도록 트리거링, 완료하면 어디까지 기록했는지 컨트롤 파일과 데이터 파일 헤더에 저장. 
        <details markdown="1">
        <summary>상세 설명</summary>
        Write Ahead Logging 방식(데이터 변경 전에 로그부터 남기는 메커니즘)을 사용하는 DBMS는 Redo 로그에 기록한 버퍼 블록에 대한 변경사항 중 어디까지 데이터 파일에 기록했는지 체크포인트 정보를 관리. 
        이는 버퍼 캐시와 데이터 파일이 동기화된 시점을 가리키며, 장애가 발생하면 마지막 체크포인트 이후 로그 데이터만 디스크에 기록함으로써 인스턴스를 복구할 수 있도록 하는 용도로 사용,  
        이 정보를 갱신하는 주기가 길수록 장애 발생 시 인스턴스 복구 시간도 길어진다.
        </details>
- Recoverer(RECO) / Distributed Transaction Coordinator(DTC)
    - 분산 트랜잭션 과정에 발생한 문제를 해결.

# 3. 파일 구조
## 가. 데이터 파일
### 1) 블록 / 페이지
- DBMS에서 I/O는 블록 단위 
    - 하나의 레코드에서 하나의 칼럼만을 읽어도 레코드가 속한 블록 전체를 읽음.
    - SQL 성능을 좌우하는 가장 중요한 성능지표는 액세스하는 블록 개수,  
    옵티마이저의 판단에 가장 큰 영향을 미치는 것도 액세스해야 할 블록 개수.
        >예를 들어, 옵티마이저가 인덱스를 이용해 테이블을 액세스할지 아니면 Full Table Scan 할지를 결정하는 데 있어 가장 중요한 판단 기준은 읽어야 할 레코드 수가 아니라 읽어야 하는 블록 개수.

### 2) 익스텐트(Extent)
- 블록: 데이터를 읽고 쓰는 단위  
익스텐트: 테이블 스페이스로부터 공간을 할당하는 단위
- 테이블이나 인덱스에 데이터를 입력 중 공간이 부족하면 해당 오브젝트가 속한 테이블 스페이스(물리적으로는 데이터 파일)로부터 추가적인 공간을 할당받는데,  
정해진 익스텐트 크기의 연속된 블록을 할당받음.
    >예를 들어, 블록 크기가 8KB인 상태에서 64KB 단위로 익스텐트를 할당하도록 정의하면, 공간이 부족할 때마다 테이블 스페이스로부터 8개의 연속된 블록을 찾아(찾지 못하면 새로 생성) 세그먼트에 할당함.
- 익스텐트 내 블록은 논리적으로 인접하지만,  
익스텐트끼리는 서로 인접하지 않음.
    >예를 들어, 어떤 세그먼트에 익스텐트 2개가 할당됐는데, 데이터 파일 내에서 이 둘이 서로 멀리 떨어져 있을 수 있음.
    ||오라클|SQL Sever|
    |-|-|-|
    |블록 크기|2, 4, 8, 16, 32, 64KB|8KB|
    |익스텐트 크기|다양함|64KB|
    |하나의 익스텐트|단일 오브젝트 사용|2개 이상 오브젝트도 가능|
- SQL Server 익스텐트 타입
    - 균일(Uniform) 익스텐트: 64KB 이상의 공간을 필요로 하는 테이블이나 인덱스를 위해 사용,  
    단일 오브젝트가 사용.
    - 혼합(Mixed) 익스텐트: 한 익스텐트에 할당된 8개 페이지를  
    여러 오브젝트가 나누어 사용.
        >모든 테이블이 혼합 익스텐트로 시작하지만,  
        64KB를 넘으면서 2번째부터 균일 익스텐트를 사용.

### 3) 세그먼트 / 힙, 인덱스 구조의 오브젝트
- 테이블, 인덱스, Undo처럼 저장공간을 필요로 하는 데이터베이스 오브젝트.  
-> 저장공간 필요 = 한 개 이상의 익스텐트를 사용.
- 테이블 생성 시 테이블 세그먼트 생성, 인덱스는 인덱스 세그먼트 생성,  
오브젝트-세그먼트 1:1 대응, 파티션-세그먼트 1:M 대응.
- 파티션 테이블(또는 인덱스)을 만들면 내부적으로 여러 개의 세그먼트를 만듦.
- 한 세그먼트는 속한 테이블 스페이스 내 여러 데이터 파일에 걸쳐 저장 가능.  
-> 세그먼트에 할당된 익스텐트가 여러 데이터 파일에 흩어져 저장. 
    >디스크 경합을 줄이고 I/O 분산 효과

### 4) 테이블 스페이스 / 파일 그룹
- 세그먼트를 담는 컨테이너 -여러 데이터 파일로 구성.
- 사용자가 세그먼트를 위한 테이블 스페이스를 지정,  
실제 값을 저장할 데이터 파일을 선택하고 익스텐트를 할당하는 것은 DBMS의 몫.
- 각 세그먼트는 하나의 테이블 스페이스에 속함,  
한 테이블 스페이스에는 여러 세그먼트가 존재.
    - 특정 세그먼트에 할당된 모든 익스텐트는 해당 세그먼트와 관련된 테이블 스페이스 내에서만 찾을 수 있음.  
    한 세그먼트가 여러 테이블 스페이스에 걸쳐 저장될 수 없음.
    - 한 세그먼트가 여러 데이터 파일에 걸쳐 저장될 수는 있음.  
    -> 한 테이블 스페이스가 여러 데이터 파일로 구성되기 때문.

    ![image](https://user-images.githubusercontent.com/105637541/194504236-51cfc2de-5b5c-4321-9b0f-655bca973cf9.png)

    ![image](https://user-images.githubusercontent.com/105637541/194504292-f4e919cc-d6a5-432d-8ecf-ad76f29c3762.png)

**- Day1**  
---2022-10-14
## 나. 임시 데이터 파일
- 대량의 정렬이나 해시 작업을 수행하다가 메모리 공간이 부족해지면 중간 결과집합을 저장.
- 저장되는 오브젝트는 임시로 저장했다가 자동으로 삭제.
- Redo 정보를 생성하지 않기 때문에 복구되지 않음. -백업 불필요.
- Oracle: 여러 개 생성, 사용자마다 지정 가능.
- SQL Server: 하나의 tempdb 데이터베이스, 전역 리소스로서 모든 사용자의 임시 데이터 저장.

## 다. 로그 파일: Redo 로그 / 트랜잭션 로그
- DB 버퍼 캐시에 가해지는 모든 변경사항을 기록하는 파일.
- 변경된 메모리 버퍼 블록을 디스크 상의 데이터 블록에 기록하는 작업은 Random I/O 방식이라 느림.  
반면, 로그 기록은 Append 방식이라 상대적으로 매우 빠름.
    - 따라서 대부분 DBMS는 버퍼 블록에 대한 변경사항을 로그 파일에 Append 방식으로 빠르게 기록.
    - 이후 버퍼 블록과 데이터 파일 간 동기화는 DBWR, Checkpoint를 이용해 Batch 방식으로 일괄 처리.
- 갱신내용이 메모리 상 버퍼 블록에만 기록된 채 디스크에 기록되지 않았어도 Redo 로그를 믿고 빠르게 커밋을 완료한다는 의미에서 Fast Commit 메커니즘이라 함.
- Online Redo 로그: 기록되지 않은 상태에서 인스턴스가 비정상 종료되는 상황에 대비하기 위해 Oracle은 Online Redo 로그를 사용함 마지막 체크포인트 이후 사고 발생 직전까지 수행된 트랜잭션을 Redo 로그를 이용해 재현 - 캐시 복구.
    - 최소 두 개 이상의 파일로 구성, 파일이 꽉 차면 다음 파일로 로그 스위칭, 모든 파일이 꽉 차면 다시 첫 번째 파일부터 재사용하는 라운드 로빈(round-robin)방식 사용.
- 트랜잭션 로그: 주 데이터 파일(데이터베이스)마다 트랜잭션 로그 파일(ldf) 생성, 내부적으로 '가상 로그 파일'이라 불리는 더 작은 단위의 세그먼트로 나뉘며, 이 가상 로그 파일의 개수가 너무 많아지는 것(조각화)을 경계하여 옵션을 지정.
    >예를 들어, 로그 파일을 애초에 넉넉한 크기로 만들어 자동 증가를 방지하거나, 증가하는 단위를 크게 지정.
- Archived(=Offline) Redo 로그: Online Redo 로그가 재사용되기 전에 다른 위치로 백업해 둔 파일. 디스크가 깨지는 등 물리적인 저장 매체에 문제가 생겼을 때 데이터베이스 복구를 위해 사용. SQL Server에는 대응되는 개념이 없음.

# 4. 메모리 구조
- 시스템 공유 메모리 영역: System Global Area(SGA) / Memory Pool
    - 여러 프로세스가 동시에 액세스할 수 있는 메모리.  
    모든 DBMS가 공통적으로 사용하는 캐시 영역으로는 DB 버퍼 캐시, 공유 풀, 로그 버퍼가 있음.  
    - 공유 메모리 영역 
        - 라지 풀, 자바 풀, 시스템 구조와 제어 구조를 캐싱하는 영역까지 포함.
        - 내부적으로 래치, 버퍼 락, 라이브러리 캐시 Lock/Pin 과 같은 액세스 직렬화 메커니즘 사용.
- 프로세스 전용 메모리 영역 Process Global Area(PGA)
    - Oracle은 프로세스 기반 아키텍처이므로 서버 프로세스가 자신만의 전용 메모리 영역을 가짐.  
    데이터를 정렬하고 세션과 커서에 관한 상태 정보를 저장하는 용도로 사용.
    - 스레드 기반 아키텍처인 SQL Server는 프로세스 전용 메모리 영역을 갖지 않음.
        - 스레드는 전용 메모리 영역을 가질 수 없고, 부모 프로세스의 메모리 영역을 사용.
            - Win Oracle도 스레드를 사용하지만 프로세스 기반의 Unix 버전과 같은 UI를 제공하고 구조에 대한 개념과 설명도 동일.

## 가. DB 버퍼 캐시
- 데이터 파일로부터 읽어 들인 데이터 블록을 담는 캐시 영역.
    - 인스턴스에 접속한 모든 사용자 프로세스는 서버 프로세스를 통해 DB 버퍼 캐시의 버퍼 블록을 동시에 액세스할 수 있음. (내부적으로는 버퍼 Lock을 통해 직렬화)
    - 일부 Direct Path Read 메커니즘이 작동하는 경우를 제외하고, 모든 블록 읽기는 버퍼 캐시를 통해 이루어짐. 즉, 읽으려는 블록을 버퍼 캐시에서 먼저 찾아보고 없을 때 디스크에서 읽음. -버퍼 캐시에 적재한 후에 읽음.
    - 데이터 변경도 버퍼 캐시에 적재된 블록을 통해 이루어지며, 변경된 블록(Dirty 버퍼 블록)을 주기적으로 데이터 파일에 기록하는 작업은 DBWR 프로세스의 몫.
    - 디스크 I/O는 물리적으로 액세스 암이 움직이면서 헤드를 통해 이루어지는 반면, 메모리 I/O는 전기적 신호이기 때문에 훨씬 빠름. -디스크에서 읽은 데이터 블록을 메모리 상에 보관해 두는 기능이 모든 데이터베이스 시스템에 필수적인 이유.

### 1) 버퍼 블록의 상태
- Free 버퍼
    - 인스턴스 기동 후 아직 데이터가 읽히지 않아 비어있는 상태(Clean 버퍼)거나, 데이터 파일과 동기화돼 있어 언제든 덮어 써도 무방한 버퍼 블록.
    - 데이터 파일로부터 새로운 데이터 블록을 로딩하려면 먼저 Free 버퍼를 확보해야 한다. Free 버퍼에 변경이 발생하면 그 즉시 Dirty 버퍼로 바뀜.
- Dirty 버퍼
    - 버퍼에 캐시된 이후 변경이 발생했지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 버퍼 블록.
    - 다른 데이터 블록을 위해 재사용되려면 디스크에 먼저 기록되어야 하며, 디스크에 기록 즉시 Free 버퍼로 바뀜.
- Pinned 버퍼
    - 읽기 또는 쓰기 작업이 진행 중인 버퍼 블록.

### 2) LRU 알고리즘(Least Recently Used)
- 버퍼 캐시는 유한한 자원이므로 모든 데이터를 캐싱해 둘 수 없음. 따라서 모든 DBMS는 사용빈도가 높은 데이터 블록 위주로 버퍼 캐시가 구성되도록 LRU 알고리즘을 사용.
- 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용빈도 순으로 위치를 옮겨가다가, Free 버퍼가 필요해지면 액세스 빈도가 낮은 쪽(LRU end) 데이터 블록부터 밀어내는 방식.  
![image](https://user-images.githubusercontent.com/105637541/195763021-6f5cfdc9-8f82-4017-9405-6de7c05a12f6.png)

## 나. 공유 풀(Shared Pool) / 프로시저 캐시
LRU 알고리즘을 사용
- 딕셔너리 캐시
    - 데이터베이스 딕셔너리
        - 테이블, 인덱스 같은 오브젝트는 물론 테이블 스페이스, 데이터 파일, 세그먼트, 익스텐트, 사용자, 제약에 관한 메타 정보를 저장하는 곳.
    - 딕셔너리 정보를 캐싱하는 메모리 영역
        >'주문' 테이블을 예로 들면, 입력한 주문 데이터는 데이터 파일에 저장됐다가 버퍼 캐시를 경유해 읽히지만, 테이블 메타 정보는 딕셔너리에 저장됐다가 딕셔너리 캐시를 경유해 읽힘.
- 라이브러리 캐시
    - 사용자가 수행한 SQL문과 실행계획, 저장 프로시저를 저장해두는 캐시영역.
    - 사용자가 결과집합을 요청하면 이를 최적으로 수행하기 위한 처리 계획. -> 빠른 쿼리 수행을 위해 내부적으로 생성한 일종의 프로시저 같은 것.
    - 하드 파싱
        - 쿼리 구문 분석 - 문법 오류 및 실행 권한 등 체크 - 최적화 - 실행계획 - SQL실행엔진 포맷팅
    - 같은 SQL을 처리하려고 최적화 과정을 반복 수행하는 것은 비효율적 -> 그를 위한 캐시 공간을 따로 둔 것이 라이브러리 캐시 영역. -캐싱된 SQL과 그 실행계획의 재사용성을 높이는 것은 SQL 수행 성능을 높이고 DBMS 부하를 최소화하는 핵심 원리 중 하나.

## 다. 로그 버퍼 / 로그 캐시
- DB 버퍼 캐시에 가해지는 모든 변경사항은 로그 파일에 기록, 로그 엔트리도 먼저 로그 버퍼에 기록함. -매번 디스크에 기록하기보다 일정량을 모아서 기록하면 훨씬 빠르기 때문.
    - 서버 프로세스가 데이터 블록 버퍼에 변경을 가하기 전에 Redo 로그 버퍼에 먼저 기록해 두면 주기적으로 LGWR 프로세스가 Redo 로그 파일에 기록함.
    - Dirty 버퍼를 데이터 파일에 기록하기 전에 로그 버퍼를 먼저 로그 파일에 기록 -인스턴스 장애가 발생하면 로그 파일에 기록된 내용을 재현해 복구하고, 커밋되지 않은 트랜잭션을 롤백.  
    -이 때 로그 파일에는 없는 변경내역이 이미 데이터 파일에 기록돼 있으면 커밋하지 않은 트랜잭션이 커밋.
- 버퍼 캐시 블록 갱신 이전에 먼저 변경사항을 로그 파일에 기록하고, Dirty 버퍼를 디스크에 기록하기 전에 해당 로그 엔트리를 먼저 로그 파일에 기록함. (Write Ahead Logging)
- 로그 버퍼를 주기적으로 로그 파일에 기록. (Log Force at commit) -메모리 상의 로그 버퍼는 언제든 유실 가능  
- 로그 파일 기록이 보장돼야 안심하고 커밋. (로그를 이용한 복구 가능)

## 라. PGA(Process Global Area)
- 각 서버 프로세스는 자신만의 PGA 메모리 영역을 할당받고, 이를 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용.  
다른 프로세스와 공유되지 않는 독립적인 메모리 공간.  
래치 메커니즘이 필요 없기 때문에 SGA 버퍼 캐시에서 읽는 것보다 훨씬 빠름.
- User Global Area(UGA)
    - 전용 서버 방식으로 연결 시 프로세스와 세션이 1:1 관계지만,  
    공유 서버 방식으로 연결 시 1:M 관계를 가짐.  
    즉, 세션이 프로세스보다 많은 구조 -각 세션을 위한 독립적인 메모리 공간(UGA)이 필요.
    - 전용 서버 방식의 경우에는 PGA에 할당,  
    공유 서버 방식으로 연결할 때는 SGA에 할당. (라지 풀 우선, 없을 시 공유 풀에 할당)
- Call Global Area(CGA)
    - 하나의 데이터베이스 Call을 넘어서 다음 Call까지 계속 참조되어야 하는 정보는 UGA에,  
    Call이 진행되는 동안에만 필요한 데이터는 CGA에 담음.
    - CGA는 Parse Call, Execute Call, Fetch Call마다 매번 할당.
    - Call 진행 중 Recursive Call이 발생하면 그 안에서 Parse, Execute, Fetch 단계별로 CGA 추가 할당.
    - CGA에 할당된 공간은 하나의 Call이 끝나면 바로 PGA로 반환.
- Sort Area
    - 데이터 정렬을 위해 사용.
    - 소트 오퍼레이션이 진행되는 동안 공간이 부족해질 때마다 청크 단위로 조금씩 할당.
    - 세션마다 사용할 수 있는 최대 크기를 이전에는 sort_area_size 파라미터로 설정했지만, 9i부터는 workarea_size_policy 파라미터를 auto로 설정하면 Oracle이 내부적으로 결정.
    - PGA 내에서 Sort Area가 할당되는 위치는 SQL문 종류와 sort 수행 단계에 따라 다름.  
    DML: 하나의 Execute Call 내에서 모든 데이터 처리를 완료하므로 Sort Area가 CGA에 할당.  
    SELECT: 수행 중간 단계에 필요한 Sort Area는 CGA에 할당, 최종 결과집합을 출력하기 직전 단계에 필요한 Sort Area는 UGA에 할당.
- 스레드 기반인 SQL Server는 프로세스 전용 메모리 영역을 갖지 않음.  
데이터 정렬은 Memory Pool 안에 있는 버퍼 캐시에서 수행, 세션 관료 정보는 Memory Pool 안의 Connection Context 영역에 저장.

# 5. 대기 이벤트 / 대기 유형(Wait Type)
- 수많은 프로세스 간에는 상호작용이 필요하며, 그 과정에서 다른 프로세스가 일을 마칠 때까지 기다려야 하는 상황이 발생.
- 해당 프로세스는 자신이 일을 계속할 수 있는 조건이 충족될 때까지 수면 상태로 대기하는데 그 기간에 정해진 간격으로(1초, 3초 등) 각 대기 유형별 상태와 시간 정보가 공유 메모리 영역에 저장.
- 대개 누적치만 저장하지만, 사용자가 원하면(10046 이벤트 트레이스 활성화) 로그처럼 파일로 기록.
- 1990년대 후반부터 이를 기반으로 한 'Response Time Analysis' 성능관리 방법론이 데이터베이스 성능 진단 분야에 일대 변혁을 가져옴.
    - 세션 또는 시스템 전체에 발생하는 병목 현상과 그 원인을 찾아 문제를 해결하는 방법과 과정을 다루는 방법론.
    - 데이터베이스 서버의 응답 시간을 서비스 시간과 대기 시간의 합으로 정의.
    - Response Time = Service Time + Wait Time = CPU Time + Queue Time
    - Service Time: 프로세스가 정상적으로 동작하며 일을 수행한 시간. (=CPU Time)
    - Wait Time: 프로세스가 수행을 잠시 멈추고 대기한 시간.
    - CPU Time과 Wait Time을 각각 Break down 하면서 서버의 일량과 대기 시간을 분석.
    - Wait Time은 가장 시간을 많이 소비한 이벤트 중심으로 해결방안 모색.
    >Oracle 10g을 기준으로 대기 이벤트 개수는 890여 개에 이르는데, 그 중 자주 발생하고 성능 문제와 직결되는 것들.  
    참고로 본 단락은 Oracle 중심으로만 설명하는데, SQL Server는 대기 유형이 잘 알려지지 않은 데다 아직 활용도가 낮은 편이기 때문.  
    DBMS 병목이 주로 어디서 발생하는지 그리고 어떤 이벤트로써 측정되는지를 간단하게나마 보여주기 위한 것.

## 가. 라이브러리 캐시 부하
- 라이브러리 캐시에서 SQL 커서를 찾고 최적화하는 과정에 경합이 발생했음을 나타내는 대기 이벤트.
    - latch: shared pool  
    latch: library cache/li>
- 라이브러리 캐시와 관련해 자주 발생하는 대기 이벤트 -수행 중인 SQL이 참조하는 오브젝트에 다른 사용자가 DDL을 수행할 때 나타남.
    - library cache lock
    - library cache pin  
라이브러리 캐시 관련 경합이 증가하면 동시성 저하를 초래함.

## 나. 데이터베이스 Call과 네트워크 부하
- 아래 이벤트에 소모된 시간은 애플리케이션과 네트워크 구간에서 소모된 시간으로 이해.
    - SQL*Net message from client  
    SQL*Net message to client  
    SQL*Net more date to client
    SQL*Net more data from client/li>
    - SQL*Net message from client 이벤트는 데이터베이스 경합과는 관련이 없음  
    -클라이언트로부터 다음 명령이 올 때까지 Idle 상태로 기다릴 때 발생하기 때문.
    - 반면, 나머지 세 이벤트는 실제 네트워크 부하가 원인일 수 있음. 세 이벤트 중 위 두 이벤트는 클라이언트에게 메시지를 보냈는데 메시지를 받았다는 신호가 늦게 도착하는 경우, 클라이언트가 너무 바쁜 경우에 나타남. 
    - SQL*Net more data from client/li> 이벤트는 클라이언트로부터 더 받을 데이터가 있는데 지연이 발생하는 경우.

## 다. 디스크 I/O 부하
- 디스크 I/O가 발생할 때마다 나타나는 대기 이벤트
    - db file sequential read  
    db file scattered read  
    direct path read  
    direct path write  
    direct path write temp  
    direct path read temp  
    db file parallel read
    - 특히 주목해야할 이벤트
    - db file sequential read
        - Single Block I/O 수행 시에 나타나는 대기 이벤트. -Sigle Block I/O는 한번의 I/O Call에 하나의 데이터 블록만 읽는 것을 말함.
    - db file scattered read
        - Multi Block I/O 수행 시에 나타나는 대기 이벤트 -I/O Call이 필요한 시점에 인접한 블록들을 같이 읽어 메모리에 적재하는 것 -Table Full Scan 또는 Index Fast Full Scan 시 나타남.

## 라. 버퍼 캐시 경합
- 버퍼 캐시에서 블록을 읽는 과정에 경합이 발생했음을 나타내는 대기 이벤트.
    - latch: cache buffers chains  
    latch: cache buffers Iru chain  
    buffer busy waits  
    dfree buffer waits
    - 버퍼 캐시에서 블록을 읽더라도 이들 대기 이벤트가 심하게 발생하는 순간 동시성은 현저히 저하되는데, 이들 대기 이벤트를 해소하는 방안도 디스크 I/O 부하 해소 방안과 다르지 않음.

## 마. Lock 관련 대기 이벤트
- enq: TM - contention  
enq: TX - row lock contention  
enq: TX - index contention  
enq: TX - allocate ITL entry  
enq: TX contention  
latch free: 특정 자원에 대한 래치를 여러 차례(2000번 가량) 요청했지만 자원이 사용중이어서 대기 상태로 빠질 때마다 발생하는 대기 이벤트.  
래치는 Lock과 조금 다름. Lock은 데이터를 보호하는 반면, 래치는 SGA에 공유돼 있는 갖가지 자료구조를 보호할 목적으로 사용하는 가벼운 Lock.  
다시 말해 래치도 일종의 Lock이지만, 큐잉 메커니즘을 사용하지 않음.  
따라서 특정 자원에 액세스하려는 프로세스는 래치 획득에 성공할 때까지 시도를 반복할 뿐, 우선권을 부여 받지는 못함. ->가장 먼저 요구했던 프로세스가 가장 늦게 얻을 수도 있음

- 위에서 소개하지 않았지만 자주 발생하는 대기이벤트
    - log file sync/li  
    checkpoint completed  
    log file switch completion  
    log buffer space

- - -
# +Note
## OLTP성 애플리케이션 -Connection Pooling 기법
## RAC(Real Application Cluster)




